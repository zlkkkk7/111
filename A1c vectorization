# Data creation routines in NumPy will generally have a first parameter which is the shape of the object. 
# This can either be a single value for a 1-D result or a tuple (n,m,...) specifying the shape of the result. 
# Below are examples of creating vectors using these routines.
  
# In NumPy and computer science, the number of "dimensions" (often called rank or ndim) refers to how many indices you need to access a single element
# so: dimension: how many indexes the array has 
# shape: size of each dimension (5,): a vector has 5 elements
# size: how many numbers of elements in the array 

## create vectors: routine that accept tuples
a = np.zeros(4);                print(f"np.zeros(4) :   a = {a}, a shape = {a.shape}, a data type = {a.dtype}") 
a = np.zeros((4,));             print(f"np.zeros(4,) :  a = {a}, a shape = {a.shape}, a data type = {a.dtype}") # tuple 
a = np.random.random_sample(4); print(f"np.random.random_sample(4): a = {a}, a shape = {a.shape}, a data type = {a.dtype}") 
# outputs 
# np.zeros(4) :   a = [0. 0. 0. 0.], a shape = (4,), a data type = float64 # float: a number with decimal 
# np.zeros(4,) :  a = [0. 0. 0. 0.], a shape = (4,), a data type = float64
# np.random.random_sample(4): a = [0.96312453 0.07279597 0.56167635 0.22620594], a shape = (4,), a data type = float64


## create vectors: routine that does not accept shape tuples
a = np.arange(4.);              print(f"np.arange(4.):     a = {a}, a shape = {a.shape}, a data type = {a.dtype}")
a = np.random.rand(4);          print(f"np.random.rand(4): a = {a}, a shape = {a.shape}, a data type = {a.dtype}")
# outputs
# np.arange(4.):     a = [0. 1. 2. 3.], a shape = (4,), a data type = float64
# np.random.rand(4): a = [0.25540764 0.61272856 0.12525905 0.92947432], a shape = (4,), a data type = float64

## create vectors: routine that infers everything from the data you provide
a = np.array([5,4,3,2]);  print(f"np.array([5,4,3,2]):  a = {a},     a shape = {a.shape}, a data type = {a.dtype}")
a = np.array([5.,4,3,2]); print(f"np.array([5.,4,3,2]): a = {a}, a shape = {a.shape}, a data type = {a.dtype}")
# outputs
# np.array([5,4,3,2]):  a = [5 4 3 2],     a shape = (4,), a data type = int64
# np.array([5.,4,3,2]): a = [5. 4. 3. 2.], a shape = (4,), a data type = float64


## indexing and slicing data 
# Indexing means referring to an element of an array by its position within the array. [#]
a = np.arange(10)
print(a)
#access an element
print(f"a[2].shape: {a[2].shape} a[2]  = {a[2]}, Accessing an element returns a scalar")
# access the last element, negative indexes count from the end
print(f"a[-1] = {a[-1]}")
#indexs must be within the range of the vector or they will produce and error
try:
    c = a[10]
except Exception as e:
    print("The error message you'll see is:")
    print(e)
# outputs
#[0 1 2 3 4 5 6 7 8 9]
#a[2].shape: () a[2]  = 2, Accessing an element returns a scalar
#a[-1] = 9
#The error message you'll see is:
#index 10 is out of bounds for axis 0 with size 10




  # Slicing means getting a subset of elements from an array based on their indices.[#:#:#]
a = np.arange(10)
print(f"a         = {a}")
#access 5 consecutive elements (start:stop:step)
c = a[2:7:1];     print("a[2:7:1] = ", c)
# access 3 elements separated by two 
c = a[2:7:2];     print("a[2:7:2] = ", c)
# access all elements index 3 and above
c = a[3:];        print("a[3:]    = ", c)
# access all elements below index 3
c = a[:3];        print("a[:3]    = ", c)
# access all elements
c = a[:];         print("a[:]     = ", c)
# outputs 
#a         = [0 1 2 3 4 5 6 7 8 9]
#a[2:7:1] =  [2 3 4 5 6]
#a[2:7:2] =  [2 4 6]
#a[3:]    =  [3 4 5 6 7 8 9]
#a[:3]    =  [0 1 2]
#a[:]     =  [0 1 2 3 4 5 6 7 8 9]


#calculation 1
a = np.array([1,2,3,4])
print(f"a             : {a}")
# negate elements of a
b = -a 
print(f"b = -a        : {b}")â€‹
# sum all elements of a, returns a scalar
b = np.sum(a) 
print(f"b = np.sum(a) : {b}")â€‹
b = np.mean(a)
print(f"b = np.mean(a): {b}")â€‹
b = a**2
print(f"b = a**2      : {b}")
# outputs 
#a             : [1 2 3 4]
#b = -a        : [-1 -2 -3 -4]
#b = np.sum(a) : 10
#b = np.mean(a): 2.5
#b = a**2      : [ 1  4  9 16]

#calculation 2 Vector Vector element-wise operations
a = np.array([ 1, 2, 3, 4])
b = np.array([-1,-2, 3, 4])

# calculation 3 multiply a by a scalar: A scalar value is just a number. The scalar multiplies all the elements of the vector.
a = np.array([1, 2, 3, 4])
b = 5 * a 
print(f"b = 5 * a : {b}")


#calculation 4 dot product
#The dot product multiplies the values in two vectors element-wise and then sums the result.
#Vector dot product requires the dimensions of the two vectors to be the same. 
# Using a for loop, implement a function which returns the dot product of two vectors. The function to return given inputs  ğ‘ and  ğ‘ : ğ‘¥=âˆ‘ğ‘–=0ğ‘›âˆ’1ğ‘ğ‘–ğ‘ğ‘–
def my_dot(a, b): 
    x=0
    for i in range(a.shape[0]):
        x = x + a[i] * b[i]
    return x
      # using my_dot (a for loop function 
a = np.array([1, 2, 3, 4])
b = np.array([-1, 4, 3, 2])
print(f"my_dot(a, b) = {my_dot(a, b)}")

# using np.dot
a = np.array([1, 2, 3, 4])
b = np.array([-1, 4, 3, 2])
c = np.dot(a, b)
print(f"NumPy 1-D np.dot(a, b) = {c}, np.dot(a, b).shape = {c.shape} ") 
c = np.dot(b, a)
print(f"NumPy 1-D np.dot(b, a) = {c}, np.dot(a, b).shape = {c.shape} ")
#outputs
#NumPy 1-D np.dot(a, b) = 24, np.dot(a, b).shape = () 
      #NumPy 1-D np.dot(b, a) = 24, np.dot(a, b).shape = () #this is a scalar so the output is empty 

# index a 2D vector and operate 
X = np.array([[1],[2],[3],[4]])
w = np.array([2])
c = np.dot(X[1], w)
print(c)
        print(f"X[1] has shape {X[1].shape}") # X[1] is a 1-D dimension vector 
print(f"w has shape {w.shape}")
print(f"c has shape {c.shape}")





## matrix 
# create matrix: both creates the same matrix 
a = np.array([[5],   # One can also
              [4],   # separate values
              [3]]); #into separate rows
print(f" a shape = {a.shape}, np.array: a = {a}")

#vector indexing operations on matrices
a = np.arange(6).reshape(-1, 2)   #reshape is a convenient way to create matrices
print(f"a.shape: {a.shape}, \na= {a}")
#access an element
print(f"\na[2,0].shape:   {a[2, 0].shape}, a[2,0] = {a[2, 0]},     type(a[2,0]) = {type(a[2, 0])} Accessing an element returns a scalar\n")
#access a row
print(f"a[2].shape:   {a[2].shape}, a[2]   = {a[2]}, type(a[2])   = {type(a[2])}")

#vector 2-D slicing operations
a = np.arange(20).reshape(-1, 10)
print(f"a = \n{a}")
#access 5 consecutive elements (start:stop:step)
print("a[0, 2:7:1] = ", a[0, 2:7:1], ",  a[0, 2:7:1].shape =", a[0, 2:7:1].shape, "a 1-D array")
#access 5 consecutive elements (start:stop:step) in two rows
print("a[:, 2:7:1] = \n", a[:, 2:7:1], ",  a[:, 2:7:1].shape =", a[:, 2:7:1].shape, "a 2-D array")
# access all elements
print("a[:,:] = \n", a[:,:], ",  a[:,:].shape =", a[:,:].shape)
# access all elements in one row (very common usage)
print("a[1,:] = ", a[1,:], ",  a[1,:].shape =", a[1,:].shape, "a 1-D array")
# same as
print("a[1]   = ", a[1],   ",  a[1].shape   =", a[1].shape, "a 1-D array")



def predict(X, w, b): 
    """
    Predict whether the label is 0 or 1 using learned logistic
    regression parameters w
    
    Args:
      X : (ndarray Shape (m,n)) data, m examples by n features
      w : (ndarray Shape (n,))  values of parameters of the model      
      b : (scalar)              value of bias parameter of the model

    Returns:
      p : (ndarray (m,)) The predictions for X using a threshold at 0.5
    """
    # number of training examples
    m, n = X.shape
    p = np.zeros (m)
   
    ### START CODE HERE ### 
    # Loop over each example
    for i in range(m):   
        z_i= np.dot(X[i], w) + b
        f_wb = sigmoid(z_i)
    

        # Apply the threshold
        p[i] = 1.0 if f_wb >= 0.5 else 0.0       
    ### END CODE HERE ### 
    return p



def predict(X, w, b): 
    m, n = X.shape
    p = np.zeros (m)
    for i in range(m):   
        z_i= 0
        for j in range(n): 
          z_i += X[i,j] * w[j]

        # Add bias term 
        z_i += b
        
        # Calculate the prediction for this example
        f_wb_i = sigmoid(z_i)
        p[i] = 1 if f_wb_i >= 0.5 else 0
    return p
